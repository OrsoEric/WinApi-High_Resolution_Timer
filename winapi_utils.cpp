/****************************************************************
**	OrangeBot  Project
*****************************************************************************
**        /
**       /
**      /
** ______ \
**         \
**          \
*****************************************************************************
**	Winapi_utils
*****************************************************************************
**	This class of static method is meant to handle the error codes of the
**	windows api system calls, and allow user to just check whetever the call
**	succeded or not.
*****************************************************************************
**	Author: 			Orso Eric
**	Creation Date:
**	Last Edit Date:
**	Revision:			1
**	Version:			1.0
****************************************************************************/

/****************************************************************************
**	HYSTORY VERSION
*****************************************************************************
**	1.0
**		>Added wrapper for CreateSemaphore
**		>Added wrapper for WaitForSingleObject for semaphores
**		>Added wrapper for ReleaseSemaphore
**		>Added wrapper for resume thread
**
****************************************************************************/

/****************************************************************************
**	DESCRIPTION
*****************************************************************************
**	Serial Dialog
****************************************************************************/

/****************************************************************************
**	KNOWN BUG
*****************************************************************************
**
****************************************************************************/

/****************************************************************************
**	INCLUDE
****************************************************************************/

#include <iostream>
//Smart types based on bit and sign
#include <stdint.h>
//window api
#include <windows.h>
//Useful commonly used functions for Win API
#include "winapi_utils.h"

/****************************************************************************
**	NAMESPACE
****************************************************************************/

using namespace std;


/****************************************************************************
**	GLOBAL VARIABILE
****************************************************************************/

/****************************************************************************
*****************************************************************************
**	PUBLIC STATIC METHODS
*****************************************************************************
****************************************************************************/

/****************************************************************************
*****************************************************************************
**	MISC GROUP
*****************************************************************************
****************************************************************************/

/****************************************************************************
**	Public Static Method
**	rand_float | float, float
*****************************************************************************
**	PARAMETER:
**		fmin, fmax	:	Range of the generated number
**	RETURN:
**	DESCRIPTION:
**	Get a random float within a given range.
**	Useful considering rand() is limited from 0 to 2^15-1
****************************************************************************/

float Winapi_utils::rand_float( float fmin, float fmax )
{
	///--------------------------------------------------------------------------
	///	STATIC VARIABILE
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	LOCAL VARIABILE
	///--------------------------------------------------------------------------

	//int random
	int irnd;
	//float random
	float frnd;

	///--------------------------------------------------------------------------
	///	CHECK AND INITIALIZATIONS
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	BODY
	///--------------------------------------------------------------------------

	//Get a random number
	irnd = rand();
	//Convert directly into float.
	frnd = fmin +(fmax -fmin)*(1.0*irnd)/32767.0;

	///--------------------------------------------------------------------------
	///	RETURN
	///--------------------------------------------------------------------------

	return frnd;
}	//end function: rand_float | float, float

/****************************************************************************
*****************************************************************************
**	HANDLE GROUP
*****************************************************************************
****************************************************************************/

/****************************************************************************
**	Public Static Method
**	close_handle | HANDLE
*****************************************************************************
**	PARAMETER:
**	RETURN:
**	DESCRIPTION:
**	Simple wrapper to lose handle that print error on cerr
****************************************************************************/

bool Winapi_utils::close_handle( HANDLE htmp )
{
	///--------------------------------------------------------------------------
	///	STATIC VARIABILE
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	LOCAL VARIABILE
	///--------------------------------------------------------------------------

	//return value
	DWORD ret;
	//return flag
	bool f_ret;

	///--------------------------------------------------------------------------
	///	CHECK
	///--------------------------------------------------------------------------

	//check parameter
	if (IS_BAD_HANDLE(htmp))
	{
		//nothing to do
		return FALSE; //OK
	}

	///--------------------------------------------------------------------------
	///	INITIALIZATIONS
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	BODY
	///--------------------------------------------------------------------------

	//Close the handle
	f_ret = CloseHandle( htmp );
	//If: FAIL
	if (f_ret == FALSE)
	{
		//Fetch error code
		ret = GetLastError();
		cerr << __FUNCTION__ <<  "> ERR: CloseHandle failed with code: " << ret << " Handle: " << htmp << endl;
		//Fail
		return TRUE;
	}

	///--------------------------------------------------------------------------
	///	FINALIZATIONS
	///--------------------------------------------------------------------------

	return FALSE;	//OK
}	//end method: close_handle | HANDLE

/****************************************************************************
*****************************************************************************
**	PERFORMANCE COUNTER GROUP
*****************************************************************************
****************************************************************************/

/****************************************************************************
**	Public Static Method
**	deltat | LARGE_INTEGER, LARGE_INTEGER
*****************************************************************************
**	PARAMETER:
**		scnt	:	Starting timestamp
**		ecnt	:	endng timestamp
**	RETURN:
**		Deltat between the two timestamps
**		ecnt -scnt
**	DESCRIPTION:
**	Calculate difference between two timestamps in ticks.
****************************************************************************/

LARGE_INTEGER Winapi_utils::deltat( LARGE_INTEGER scnt, LARGE_INTEGER ecnt )
{
	///--------------------------------------------------------------------------
	///	STATIC VARIABILE
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	LOCAL VARIABILE
	///--------------------------------------------------------------------------

	//return deltat
	LARGE_INTEGER ret;

	///--------------------------------------------------------------------------
	///	CHECK
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	INITIALIZATIONS
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	BODY
	///--------------------------------------------------------------------------

	//Calculate difference
	ret.QuadPart = ecnt.QuadPart -scnt.QuadPart;

	///--------------------------------------------------------------------------
	///	FINALIZATIONS
	///--------------------------------------------------------------------------

	return ret;	//OK
}	//end method:	deltat | LARGE_INTEGER, LARGE_INTEGER

/****************************************************************************
**	Public Static Method
**	deltat	| LARGE_INTEGER, LARGE_INTEGER, float
*****************************************************************************
**	PARAMETER:
**		scnt, ecnt	: Performance counter value. Returned by QueryPerformanceCounter
**	RETURN:
**		float		: elapsed time
**	DESCRIPTION:
**	This utility function take the start and end count from QueryPerformanceCounter
**	and return the time elapsed
****************************************************************************/

float Winapi_utils::deltat( LARGE_INTEGER scnt, LARGE_INTEGER ecnt, LARGE_INTEGER freq )
{
	///--------------------------------------------------------------------------
	///	STATIC VARIABILE
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	LOCAL VARIABILE
	///--------------------------------------------------------------------------

	//return value
	float ret;

	///--------------------------------------------------------------------------
	///	CHECK AND INITIALIZATIONS
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	BODY
	///--------------------------------------------------------------------------

	//Calculate deltat
	ret = 1.0 *(ecnt.QuadPart -scnt.QuadPart) /freq.QuadPart;

	///--------------------------------------------------------------------------
	///	RETURN
	///--------------------------------------------------------------------------

	return ret;
}	//end function: deltat	| LARGE_INTEGER, LARGE_INTEGER, float

/****************************************************************************
**	Public Static Method
**	time_calc_us	| LARGE_INTEGER, LARGE_INTEGER
*****************************************************************************
**	PARAMETER:
**		scnt, ecnt	: Performance counter value. Returned by QueryPerformanceCounter
**	RETURN:
**		float		: elapsed time
**	DESCRIPTION:
**	This utility function take the start and end count from QueryPerformanceCounter
**	and return the time elapsed
****************************************************************************/

float Winapi_utils::time_calc( LARGE_INTEGER scnt, LARGE_INTEGER ecnt )
{
	///--------------------------------------------------------------------------
	///	STATIC VARIABILE
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	LOCAL VARIABILE
	///--------------------------------------------------------------------------

	//counter frequency.
	LARGE_INTEGER freq;
	//return value
	float ret;

	///--------------------------------------------------------------------------
	///	CHECK AND INITIALIZATIONS
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	BODY
	///--------------------------------------------------------------------------

	QueryPerformanceFrequency( &freq );

	ret = 1.0 *(ecnt.QuadPart -scnt.QuadPart) /freq.QuadPart;

	///--------------------------------------------------------------------------
	///	RETURN
	///--------------------------------------------------------------------------

	return ret;
}	//end function: Gui_utils::time_calc_us

/****************************************************************************
*****************************************************************************
**	SEMAPHORE GROUP
*****************************************************************************
****************************************************************************/

/****************************************************************************
**	Public Method
**	born_sem | void
*****************************************************************************
**	PARAMETER:
**	RETURN:
**		HANDLE: Handle to the created semaphore
**	DESCRIPTION:
**	Create a windows semaphore
**	Handle error codes
****************************************************************************/

HANDLE Winapi_utils::born_sem( int max_users )
{
	///--------------------------------------------------------------------------
	///	STATIC VARIABILE
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	LOCAL VARIABILE
	///--------------------------------------------------------------------------

	//Temp handle to semaphore
	HANDLE hsem;
	//return value
	DWORD ret;

	///--------------------------------------------------------------------------
	///	CHECK
	///--------------------------------------------------------------------------

	//Check Parameters
	if (max_users <= 0)
	{
		cerr << __FUNCTION__ <<  "> ERR: Semaphore must have at least one user\n";
		return INVALID_HANDLE_VALUE;
	}
	else if (max_users > WINAPI_UTILS_SEM_MAX_USERS)
	{
		cerr << __FUNCTION__ <<  "> ERR: Too many maximum users for semaphore.\n";
		return INVALID_HANDLE_VALUE;
	}

	///--------------------------------------------------------------------------
	///	INITIALIZATIONS
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	BODY
	///--------------------------------------------------------------------------

	///----------------------------------------------------------------
	///	Create Semaphore
	///----------------------------------------------------------------
	//"Local\My_sem_name"	//Name of the semaphore. Local session.
	//"Global\My_sem_name"	//Name of the semaphore.

	//Create a semaphore and get the handle
	hsem =
	CreateSemaphore
	(
		NULL,			//Attributes. Cannot be inherited.
		max_users,		//Initial count. Semaphore is initialized as unused.
		max_users,		//Maximum count. Number of concurrent accesses allowed.
		NULL			//Unnamed semaphore
	);
	//If: failed to create semaphore
	if (IS_BAD_HANDLE( hsem ))
	{
		//Fetch error code
		ret = GetLastError();
		//
		switch (ret)
		{
			case ERROR_ALREADY_EXISTS:
			{
				cerr << __FUNCTION__ <<  "> ERR: Semaphore already exists. Not an error, but unhandled yet.\n";
				break;
			}
			default:
			{
				cerr << __FUNCTION__ <<  "> ERR: Failed to create semaphore with code: " << ret << endl;
			}
		};
		return INVALID_HANDLE_VALUE; //fail
	}	//If: failed to create semaphore

	///--------------------------------------------------------------------------
	///	FINALIZATIONS
	///--------------------------------------------------------------------------

	return hsem;	//OK
}	//end method: make_sem | void

/****************************************************************************
**	Public Static Method
**	lock_sem | int
*****************************************************************************
**	PARAMETER:
**	RETURN:
**	DESCRIPTION:
****************************************************************************/

bool Winapi_utils::lock_sem( HANDLE hsem, int timeout )
{
	///--------------------------------------------------------------------------
	///	STATIC VARIABILE
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	LOCAL VARIABILE
	///--------------------------------------------------------------------------

	//return
	DWORD ret;
	//return flag
	bool f_ret;

	///--------------------------------------------------------------------------
	///	CHECK
	///--------------------------------------------------------------------------

	if (IS_BAD_HANDLE(hsem) == TRUE)
	{
		cerr << __FUNCTION__ << "> ERR: Bad semaphore handle\n";
		return TRUE; //Fail
	}

	///--------------------------------------------------------------------------
	///	INITIALIZATIONS
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	BODY
	///--------------------------------------------------------------------------

	ret =
	WaitForSingleObject
	(
		hsem,			//Handle
		timeout			//Timeout
	);
	//Init to FAIL
	f_ret = TRUE;
	//Switch: WaitForSingleObject return
	switch (ret)
	{
		//System Call failed
		case WAIT_FAILED:
		{
			//Get error code
			ret = GetLastError();
			cerr << __FUNCTION__ << "> ERR: Failed to create semaphore with code: " << ret << endl;
			break;
		}
		//Thread ended without releasing the mutex. This thread becomeowner of the stray semaphore.
		case WAIT_ABANDONED:
		{
			cerr << __FUNCTION__ << "> ERR: Became owner of semaphore!";
			break;
		}
		//Wait ended without access being granted.
		case WAIT_TIMEOUT:
		{
			//try again later
			break;
		}
		//Access was granted
		case WAIT_OBJECT_0:
		{
			f_ret = FALSE; 	//Success
			break;
		}
		default:
		{
			cerr << __FUNCTION__ << "> ERR: Algorithmic Error: unknown return code\n";
		}
	}	//End Switch: WaitForSingleObject return

	///--------------------------------------------------------------------------
	///	FINALIZATIONS
	///--------------------------------------------------------------------------

	return f_ret;	//OK
}	//end method:	lock_sem | int

/****************************************************************************
**	Public Static Method
**	unlock_sem | HANDLE
*****************************************************************************
**	PARAMETER:
**	RETURN:
**	DESCRIPTION:
****************************************************************************/

bool Winapi_utils::unlock_sem( HANDLE hsem )
{
	///--------------------------------------------------------------------------
	///	STATIC VARIABILE
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	LOCAL VARIABILE
	///--------------------------------------------------------------------------

	//return value
	DWORD ret;
	//ret flag
	bool f_ret;

	///--------------------------------------------------------------------------
	///	CHECK
	///--------------------------------------------------------------------------

	if (IS_BAD_HANDLE(hsem) == TRUE)
	{
		cerr << __FUNCTION__ << "> ERR: Bad semaphore handle\n";
		return TRUE; //Fail
	}

	///--------------------------------------------------------------------------
	///	INITIALIZATIONS
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	BODY
	///--------------------------------------------------------------------------

	f_ret =
	ReleaseSemaphore
	(
		hsem,			//Handle to sempahore
		1,				//Release count by 1
		NULL			//load current count in the given var.
	);

	//If: fail
	if (f_ret == FALSE)
	{
		//Get error code
		ret = GetLastError();
		//
		cerr << __FUNCTION__ << " Failed with code: " << ret << endl;
	}

	///--------------------------------------------------------------------------
	///	FINALIZATIONS
	///--------------------------------------------------------------------------

	return FALSE;	//OK
}	//end method: unlock_sem | HANDLE

/****************************************************************************
*****************************************************************************
**	THREAD GROUP
*****************************************************************************
****************************************************************************/

/****************************************************************************
**	Public Static Method
**	pause_thread | HANDLE
*****************************************************************************
**	PARAMETER:
**	RETURN:
**		FALSE: OK
**		TRUE: fail
**	DESCRIPTION:
**	Suspend a thread.
**	Simple wrapper that prints errors
****************************************************************************/

bool Winapi_utils::pause_thread( HANDLE hthread )
{
	///--------------------------------------------------------------------------
	///	STATIC VARIABILE
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	LOCAL VARIABILE
	///--------------------------------------------------------------------------

	//return value
	DWORD ret;

	///--------------------------------------------------------------------------
	///	CHECK
	///--------------------------------------------------------------------------

	if (IS_BAD_HANDLE(hthread) == TRUE)
	{
		cerr << __FUNCTION__ << "> ERR: Bad thread handle\n";
		return TRUE; //Fail
	}

	///--------------------------------------------------------------------------
	///	INITIALIZATIONS
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	BODY
	///--------------------------------------------------------------------------

	//resume
	ret = SuspendThread( hthread );
	//If: resume failed
	if (ret == (DWORD)-1)
	{
		//Get the error code
		ret = GetLastError();
		cerr << __FUNCTION__ << "> ERR: SuspendThread failed with code: " << ret << endl;
		return TRUE;
	}

	///--------------------------------------------------------------------------
	///	FINALIZATIONS
	///--------------------------------------------------------------------------

	return FALSE;	//OK
}	//end method: resume_thread | HANDLE

/****************************************************************************
**	Public Static Method
**	resume_thread | HANDLE
*****************************************************************************
**	PARAMETER:
**	RETURN:
**		FALSE: OK
**		TRUE: fail
**	DESCRIPTION:
**	Resume a thread.
**	Simple wrapper that prints errors
****************************************************************************/

bool Winapi_utils::resume_thread( HANDLE hthread )
{
	///--------------------------------------------------------------------------
	///	STATIC VARIABILE
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	LOCAL VARIABILE
	///--------------------------------------------------------------------------

	//return value
	DWORD ret;

	///--------------------------------------------------------------------------
	///	CHECK
	///--------------------------------------------------------------------------

	if (IS_BAD_HANDLE(hthread) == TRUE)
	{
		cerr << __FUNCTION__ << "> ERR: Bad thread handle\n";
		return TRUE; //Fail
	}

	///--------------------------------------------------------------------------
	///	INITIALIZATIONS
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	BODY
	///--------------------------------------------------------------------------

	//resume
	ret = ResumeThread( hthread );
	//If: resume failed
	if (ret == (DWORD)-1)
	{
		//Get the error code
		ret = GetLastError();
		cerr << __FUNCTION__ << "> ERR: ResumeThread failed with code: " << ret << endl;
		return TRUE;
	}

	///--------------------------------------------------------------------------
	///	FINALIZATIONS
	///--------------------------------------------------------------------------

	return FALSE;	//OK
}	//end method: resume_thread | HANDLE

/****************************************************************************
**	Public Static Method
**
*****************************************************************************
**	PARAMETER:
**	RETURN:
**	DESCRIPTION:
****************************************************************************/

bool Winapi_utils::dummy( void )
{
	///--------------------------------------------------------------------------
	///	STATIC VARIABILE
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	LOCAL VARIABILE
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	CHECK
	///--------------------------------------------------------------------------

	if (FALSE)
	{
		cerr << __FUNCTION__ << ":\n";
		return TRUE; //Fail
	}

	///--------------------------------------------------------------------------
	///	INITIALIZATIONS
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	BODY
	///--------------------------------------------------------------------------

	///--------------------------------------------------------------------------
	///	FINALIZATIONS
	///--------------------------------------------------------------------------

	return FALSE;	//OK
}	//end method:
